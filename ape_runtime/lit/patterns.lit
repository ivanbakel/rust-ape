@title Ape's pattern representation

@code_type rust .rs

--- patterns.rs
@{imports}

@{the pattern trait}
---

@s The pattern trait

The `Pattern` trait is Ape's representation of a generic way of doing runtime matching. A `Pattern` matches some input, which is decided by a type parameter constrained by being a `ParseFeed`
--- imports+=
use crate::{ParseFeed};
---
--- the pattern trait
pub trait Pattern<PF: ParseFeed> {
  @{pattern features}
}

@{some handy pattern impls}
--- 

What does a `Pattern` do? That depends on its `PF` type parameter, and some `Output` type. The output is decided by the input and whatever is implementing the trait, so it's an associated type.
--- pattern features+=
type Output;
---

Then a `Pattern` will take some form of `ParseFeed`, and maybe, if it matches, produce some kind of `Output`, or have the option to fail - errors are encoded as Ape's own `Error` type.
--- imports+=
use crate::{Result};
---

--- pattern features+=
fn pmatch(self, parse_feed: &mut PF) -> Result<Self::Output>;
---

Why are we constraining the trait in this way? After all, the trait could omit the `PF` parameter and instead have it be generic in `pmatch()`, but then we would encounter a problem: we want to be able to use functions as patterns, but a function wouldn't be able to implement that generic-in-method trait because it would need to be generic in its `Fn` trait, which Rust doesn't let us express. So instead `Pattern` impls are expected to be for all `ParseFeed`s for utility.

@s Example impls

@ss Function implementation

Since `Pattern` is a "functional interface", it has a natural implementation on things which are functions of the same signature - just call the function.
--- some handy pattern impls+=
impl<Func, Input, Output, PF: ParseFeed<Item=Input>> Pattern<PF> for Func where
  Func: Fn(&mut PF) -> Result<Output> {
  type Output = Output;

  fn pmatch(self, parse_feed: &mut PF) -> Result<Output> {
    self(parse_feed)
  }
}
---

