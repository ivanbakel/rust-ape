@title Ape - an Arbitrary-type Parser Expression Grammar library

@code_type rust .rs

Ape is a library for producing Parser Expression Grammars over any type, using Rust's native pattern-matching syntax, in the style of kevinmehall's `rust-peg`. Ape aims to let you write a parser using an intuitive `peg`-style syntax and the same concepts as `&str`-parsers - in particular

 * pattern binding and postprocessing in native Rust
 * zero-copy parsing over sliceable sources
 * natural expressive power, like sequences, alternatives, and negation

@s The macro file

Ape's macro code is a library file, which has the standard Rust format

--- lib.rs
@{crates}

@{imports}

@{content}
---

@s The `arb_peg!` macro
 
An Ape parser is produced by the `arb_peg!` procedural macro, which does the work of generating an Ape AST and outputting pure Rust. Proc macros are declared as functions over `TokenStream`s, with the `[proc_macro]` attribute

--- content+=
#[proc_macro]
pub fn arb_peg(tokens: TokenStream) -> TokenStream {
  @{build an arbitrary parser from tokens}
}
---

Procedural macros require the `proc_macro` crate.

--- crates+=
extern crate proc_macro;
---

and `TokenStream`, above, needs to be imported

--- imports+=
use self::proc_macro::TokenStream; 
---

Finally, we define the high-level flow of the macro - first, an AST is build to represent the pattern for which code needs to be generated; then, the generated Rust is produced by walking the AST.

--- build an arbitrary parser from tokens
let ast = self::ast::build(tokens);
self::code::generate(ast)
---

These steps are defined in the appropriate modules:

--- lib.rs+=
mod ast;
mod code;
---

@s Extending Ape

To produce your own pattern types, you can simply extend the `Pattern` trait. This trait is described in the runtime crate.
