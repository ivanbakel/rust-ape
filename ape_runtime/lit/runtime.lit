@title The Ape runtime

@code_type rust .rs

@s The library file

The library file follows the typical Rust format - attributes, imports, modules, and then the body. However, macros are declared later which are used in submodules, so they must come before the module declarations.

--- lib.rs+=
@{crate attributes}

@{imports}

@{macros}

@{modules}

@{the runtime code}
---

--- imports
---

@s Modules

There are two modules in the crate
 * `patterns`, which defines what a pattern is and how it can be used
 * `feed`, which defines what a matchable feed of items is and how it can be used
Their contents is re-exported for ease of use. 
--- modules
pub mod patterns;
pub use crate::patterns::*;
pub mod feed;
pub use crate::feed::*;
---

@s Errors

Patterns must be able to fail, so we reexport a custom `Result` type with a pattern `Error` type - a standard feature for libraries.

--- the runtime code+=
pub type Result<T> = std::result::Result<T, Error>;

pub struct Error {
  kind: ErrorKind,
  message: String,
}

impl Error {
  pub fn kind(&self) -> &ErrorKind {
    &self.kind
  }

  pub fn message(&self) -> &str {
    &self.message
  }
}

@{error kind annotation}
pub enum ErrorKind {
  @{possible errors}
}
---

We provide some basic errors for handy use 
 * an out-of-values error
 * a mismatch error
 * any other kind of error people might want to generate later
--- possible errors+=
UnexpectedEndOfInput,
Mismatch,
Other,
---

It's common for new errors to be added over time, so we consider this list non-exhaustive - this annotation enforces the possibility of new errors on programmers dealing with different kinds.
--- crate attributes+=
#![feature(non_exhaustive)]
---

--- error kind annotation
#[non_exhaustive]
---

@ss Error macros

For ease of use, we also export some small macros for generating errors.

--- macros+=
@{error macros}
---

This macro produces a customised mismatch error
--- error macros+=
#[macro_export]
macro_rules ! mismatch {
  @{mismatch macro}
}
---
which accepts no arguments, and produces an empty message
--- mismatch macro+=
() => {{
  Error { kind: ErrorKind::Mismatch, message: format!("") }
}};
---
or variadic arguments, and produces a formatted message with the `format!` macro
--- mismatch macro+=
($($arg:expr),+) => {{
  Error { kind: ErrorKind::Mismatch, message: format!($($arg),+) }
}}; 
---

This macro produces a simple end-of-input error
--- error macros+=
#[macro_export]
macro_rules ! unexpected_end_of_input {
  () => {{
    Error { kind: ErrorKind::UnexpectedEndOfInput, message: format!("Unexpected end of input.") }
  }};
}

