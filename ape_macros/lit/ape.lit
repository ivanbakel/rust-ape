@title Ape - an Arbitrary-type Parser Expression Grammar library

@code_type rust .rs

Ape is a library for producing Parser Expression Grammars over any type, using Rust's native pattern-matching syntax, in the style of kevinmehall's `rust-peg`. Ape aims to let you write a parser using an intuitive `peg`-style syntax and the same concepts as `&str`-parsers - in particular

 * pattern binding and postprocessing in native Rust
 * zero-copy parsing over sliceable sources
 * natural expressive power, like sequences, alternatives, and negation

@s The macro file

Ape's macro code is a library file, which has the standard Rust format

--- lib.rs
@{crates}

@{imports}

@{content}
---

@s The `arb_peg!` macro
 
An Ape parser is produced by the `arb_peg!` procedural macro, which does the work of generating an Ape AST and outputting pure Rust. Proc macros are declared as functions over `TokenStream`s, with the `[proc_macro]` attribute

--- content+=
#[proc_macro]
pub fn arb_peg(tokens: TokenStream) -> TokenStream {
  @{build an arbitrary parser from tokens}
}
---

Procedural macros require the `proc_macro` crate. We also enable some optional features, namely the ability to quasi-quote Rust code (useful for a macro), the ability to use `Span`s for error message purposes, the ability to use macros as items, and the ability to create error messages.
--- crates+=
#![feature(proc_macro_quote)]
#![feature(proc_macro_span)]
#![feature(proc_macro_hygiene)]
#![feature(proc_macro_diagnostic)]
extern crate proc_macro;
---

and `TokenStream`, above, needs to be imported, along with the rest of the Rust AST

--- imports+=
use crate::proc_macro::*;
---

Finally, we define the high-level flow of the macro - first, an AST is build to represent the pattern for which code needs to be generated; then, the generated Rust is produced by walking the AST.

--- build an arbitrary parser from tokens
let ast = self::parsing::parse(tokens);
match ast {
  Ok(tree) => self::code::generate(tree),
  Err(parsing::Error { message, location }) => {
    location.error(message).emit();
    quote!()
  },
}
---

These steps are defined in the appropriate modules:

--- lib.rs+=
mod ast;
mod parsing;
mod code;
---

@s Syn

Syn is used to do some parsing of Rust syntax. Its features are explained more in the `parsing` module.
--- crates+=
extern crate syn;
---

