@title Ape's pattern representation

@code_type rust .rs

--- patterns.rs
@{imports}

@{the pattern trait}
---

@s The pattern trait

The `Pattern` trait is Ape's representation of a generic way of doing runtime matching. A `Pattern` matches some input, which is decided by a type parameter constrained by being a `ParseFeed`
--- imports+=
use crate::{ParseFeed};
---
--- the pattern trait
pub trait Pattern<PF: ParseFeed> {
  @{pattern features}
}

@{some handy pattern impls}
--- 

What does a `Pattern` do? That depends on its `PF` type parameter, and some `Output` type. The output is decided by the input and whatever is implementing the trait, so it's an associated type.
--- pattern features+=
type Output;
---

Then a `Pattern` will take some form of `ParseFeed`, and maybe, if it matches, produce some kind of `Output`, or have the option to fail - errors are encoded as Ape's own `Error` type.
--- imports+=
use crate::{Result};
---

--- pattern features+=
fn pmatch(self, parse_feed: &mut PF) -> Result<Self::Output>;
---

Why are we constraining the trait in this way? After all, the trait could omit the `PF` parameter and instead have it be generic in `pmatch()`, but then we would encounter a problem: we want to be able to use functions as patterns, but a function wouldn't be able to implement that generic-in-method trait because it would need to be generic in its `Fn` trait, which Rust doesn't let us express. So instead `Pattern` impls are expected to be for all `ParseFeed`s for utility.

@s Example impls

@ss Function implementation

Since `Pattern` is a "functional interface", it has a natural implementation on things which are functions of the same signature - just call the function.
--- some handy pattern impls+=
impl<Func, Input, Output, PF: ParseFeed<Item=Input>> Pattern<PF> for Func where
  Func: Fn(&mut PF) -> Result<Output> {
  type Output = Output;

  fn pmatch(self, parse_feed: &mut PF) -> Result<Output> {
    self(parse_feed)
  }
}
---

@ss Using Eq instances as patterns

There's a natural way to use an equatable value as a pattern - match on equality. If the next value is equal to the thing we're using as a pattern, then we match successfully - otherwise, we return an error. Note that we have to wrap in a concrete type to avoid conflicting with the previous `impl`

--- some handy pattern impls+=
pub struct Equatable<E>(E);
---

To autogenerate the mismatch error, we use the `Debug` trait, similarly to `unwrap()`, and the macro defined in the crate
--- imports+=
use std::fmt;
---

--- some handy pattern impls+=
impl<T, PF: ParseFeed<Item=T>> Pattern<PF> for Equatable<T> where T: Eq, T: fmt::Debug {
  @{the Eq impl}
}
---

--- the Eq impl+=
fn pmatch(self, parse_feed: &mut PF) -> Result<T> {
  let comparable = parse_feed.expect()?;
  let Equatable(value) = self;
  if value == comparable {
    Ok(comparable)
  } else {
    Err(mismatch!("Expected {:?}, got {:?}", value, comparable))
  }
}
---

The `Input` type is then `T`. The `Output` type is less obvious - but we'll just make it `T` - there's no reason to discard the element if there's a match.

--- the Eq impl+=
type Output = T;
---

@ss The Iterator instance

There's a natural way to use a sequence of patterns as a pattern - match all the patterns in the sequence. The `Input` for the sequence is the same as the `Input` of the individual elements - the `Output` is a `Vec` of the matched inputs. If any of the patterns fail, we return that error.

Note that, as before, this can't be done directly on the `Iterator` trait - that would conflict with the `Fn` declaration. Instead, we wrap with a concrete type for the `impl`

--- some handy pattern impls+=
pub struct Iter<I>(I);
---

and then implement the trait

--- some handy pattern impls+=
impl<Input, PF: ParseFeed<Item=Input>, I> Pattern<PF> for Iter<I> where I: Iterator, I::Item: Pattern<PF> {
  type Output = Vec<<I::Item as Pattern<PF>>::Output>;

  fn pmatch(self, parse_feed: &mut PF) -> Result<Self::Output> {
    let mut matched = vec![];
    let Iter(iter) = self;
    for pattern in iter {
        let result = pattern.pmatch(parse_feed)?;

        matched.push(result);
    }
    Ok(matched)
  }
}
---

