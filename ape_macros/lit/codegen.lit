@title Generating Rust from Ape

@code_type rust .rs

The codegen logic falls under one main function, which takes the AST generated by the parser

--- imports+=
use super::ast::{Pattern, PatternType};
---

and produces the code for the macro invocation

--- imports+=
use crate::proc_macro::*;
---

The generated code is built inside-out - first the code for the body is generated, then it is embedded in the pattern code, 

--- code.rs
@{imports}

pub(crate) fn generate(pattern: Pattern) -> TokenStream {
  let pattern = generate_pattern_with_body(pattern, quote!{});
  quote! {
    {
      $pattern
    }
  }
}
  
fn generate_pattern_with_body(pattern: Pattern, given_body: TokenStream) -> TokenStream {
  let body = {
    @{generate code for body}
  };
  @{generate the matching code}
  @{build the pattern object}
}
---

@s Generating the pattern body

The body has to actually run the code after the pattern matches, if it is defined - otherwise, the code body can be empty
--- generate code for body +=
let return_value = if let Some(code) = pattern.code_block {
  quote! {
    $given_body
    Ok({
      $code
    })
  }
} else {
  quote! {
    $given_body 
    Ok(()) 
  }
};
---

It also has to run the guard - if the guard fails, the pattern should fail. Otherwise, the pattern succeeds - and we run the code we generated above
--- generate code for body+=
if let Some(guard) = pattern.guard {
  quote! {
    @{generate the guarded code}
  }
} else {
  return_value
}
---

The guard is just a conditional on some variables which are in scope, so we can represent it as an if. Additionally, to help the user find what condition is failing, we can use the direct printing of the `TokenStream` in the error message. Finally, we embed the code in the centre
--- generate the guarded code
if $guard {
  $return_value
} else {
  Err(ape_runtime::mismatch!("Expected the value to pass `{}`", stringify!($guard)))
}
---

@s Generating the matching code

The main part of the variant matching is a big `match` statement
--- generate the matching code
let matching = match pattern.variant {
  PatternType::Raw(rust_pattern) => {
    @{raw rust pattern}
  },
  PatternType::Sequence(mut patterns) => {
    @{sequence of patterns}
  },
  PatternType::Alternation(patterns) => {
    @{alternation of patterns}
  },
  PatternType::Negation(pattern) => {
    @{pattern negation}
  },
  PatternType::Lookahead(pattern) => {
    @{pattern lookahead}
  },
  PatternType::Optional(pattern) => {
    @{optional pattern}
  },
  PatternType::Repetition {
    pattern,
    at_least,
    at_most,
    delimiter,
  } => {
    @{repeated pattern}
  },
  PatternType::Runtime(runtime) => {
    @{runtime pattern}
  },
};
---

For a raw pattern, we can test a match and bind any variables with a simple `if let`. If there's no next token, we should error.
--- raw rust pattern
quote! {
  let next = feed.expect()?;
  if let $rust_pattern = next {
    Ok({
      $body
    })
  } else {
    Err(ape_runtime::mismatch!("Expected value to match `{}`", stringify!($rust_pattern)))
  }
}
---

For a runtime pattern, we can test a match by simply calling the method on the `Pattern` trait implementation.
--- runtime pattern
quote! {
  let pattern = {
    $runtime
  };
  pattern.pmatch(feed)?;
  $body
}
---

The lookahead of a pattern just involves matching it and then reverting to the previous parse-state
--- pattern lookahead
let lookahead_pattern = generate_pattern_with_body(*pattern, quote!{});
quote! {
  let old_feed = feed.attempt();
  if let Err(error) = {
    $lookahead_pattern
  } {
    Err(error)
  } else {
    feed.commit(&old_feed);
    $body
  }
}
---

The negation of a given pattern can be tested by simply swapping the success and error states, as well as performing the lookahead logic
--- pattern negation
let inner_pattern = generate_pattern_with_body(*pattern, quote!{});
quote! {
  let old_feed = feed.attempt();
  if let Ok(success) = {
    $inner_pattern
  } {
    Err(ape_runtime::mismatch!("Expected the pattern to fail"))
  } else {
    feed.commit(&old_feed);
    $body
  }
}
---

To make a pattern optional, we can simply discard the error state and restore the original feed - but the return type becomes an `Option` of the original return type
--- optional pattern
let inner_pattern = generate_pattern_with_body(*pattern, quote!{});
quote! {
  let old_feed = feed.attempt();
  if let Ok(_) = {
    $inner_pattern
  } {
    Ok(Some({
      $body
    }?))
  } else {
    feed.commit(&old_feed);
    Ok(None)
  }
}
---

To repeat a pattern, we can require it for `at_least` many repetitions, and make it optional until `at_most` many repetitions.
--- repeated pattern
let pattern = generate_pattern_with_body(*pattern, quote!{});
if let Some(delimiter) = delimiter {
  let delimiter = generate_pattern_with_body(*delimiter, quote!{});
  quote! {
    let mut matched = false;
    for i in 0 .. $at_most {
      if i >= $at_least {
        @{delimiter before the minimum matches}
        @{after the minimum matches}
      } else {
        @{delimiter after the minimum matches}
        @{before the minimum matches}
      }
    }
    $body
  }
} else {
  quote! {
    for i in 0 .. $at_most {
      if i >= $at_least {
        @{after the minimum matches}
      } else {
        @{before the minimum matches}
      }
    }
    $body
  }
}
---

The logic before we've hit the minimum number of matches is simple: if there has been at least one match, match the delimiter
--- delimiter before the minimum matches+=
if matched {
  {
    $delimiter
  }?;
}
---
then match the pattern.
--- before the minimum matches+=
{
  $pattern
}?;
matched = true;
---

Once we've hit the minimum number of matches, the logic is more complicated: if there's been at least one match, we need to try to match the delimiter - but if we fail to, we simply fail out of the loop
--- delimiter after the minimum matches+=
if matched {
  let old_feed = feed.attempt();
  if !{
    $delimiter
  }.is_ok() {
    feed.commit(&old_feed);
    break;
  }
}
---
then we match the pattern - again, if we fail to match, we simply fail out of the loop
--- after the minimum matches+=
let old_feed = feed.attempt();
if let Ok(_) = {
  $pattern
} {
  matched = true;
} else {
  feed.commit(&old_feed);
  break;
}
---

To sequence patterns, we nest their success cases - if we sequence the successes, we won't have access to the variables in each successive scope. To do this, we generate the patterns from the end first, nesting in reverse
--- sequence of patterns +=
let mut nested = body;
while let Some(pattern) = patterns.pop() {
  nested = generate_pattern_with_body(pattern, nested);
}
nested
---

To alternate patterns, we could build each one with the given body, to allow alternate patterns to bind the same variables and have them work correctly - but this design would present some problems:
  * if the alternation appeared in the sequence, then failures after the alternation in the sequence would cause a rollback to the alternation, which is unexpected
  * the only way to not have the alternation as the top-level pattern is to bracket it, but brackets would also be expected to control scope - if a bracketed alternation produced bound variables that escaped the brackets, it would be confusing

Instead, patterns are tested by using `or_else()`, and the body is run if there was a success
--- alternation of patterns
let mut alternatives = patterns.into_iter().map(|pattern| {
  let generated = generate_pattern_with_body(pattern, quote!{});
  quote! {
    { 
      $generated
    }
  }
});
let first = alternatives.next().expect("At least one pattern in the alternative set");

let alternation = alternatives.fold(first, |alternatives, next| {
  quote! {
    $alternatives
      .or_else(|| {
        feed.commit(initial_feed);
        $next
      })
  }
});

quote! {
  let initial_feed = feed.attempt();
  $alternation.map(|_| {
    $body
  })
}
---

@ss Building the Pattern object

Finally, we have to return a value which implements the `Pattern` trait, to allow it to actually be used for matching. We can do this by wrapping the matching code we've built in a closure - as the `Pattern` trait is implemented for anything implementing the right `Fn` signature.
--- build the pattern object
quote! {
  |feed| {
    $matching
  }
}
---

