@title The Ape runtime

@code_type rust .rs

@s The library file

--- lib.rs+=
@{imports}

@{the runtime code}
---

@s Parsing at runtime

The runtime code has to act on some source of matchables. Ape represents this as a `ParseState`, which holds a backtracking `Iterator` of matchables.

--- the runtime code+=
pub struct ParseState<I> where I: Iterator {
  iterator: BacktrackingIterator<I>,
  global_position: usize,
}
---

--- imports+=
extern crate backtracking_iterator;

use backtracking_iterator::BacktrackingIterator;
---

A pattern might partially consume some values before failing to match, so the `ParseState` needs a way to put values "back on" the internal iterator before trying an alternative branch. This is possible with `BacktrackingIterator`'s `backtrack()` method. Successful matches can be prevented from being backtracked on using the `forget()` method.

Patterns must be able to fail, so we reexport a custom `Result` type with a pattern `Error` type - a standard feature for libraries.

--- the runtime code+=
pub type Result<T> = std::result::Result<T, Error>;

pub struct Error {
  kind: ErrorKind,
  message: Option<String>,
}

pub enum ErrorKind {
  @{possible errors}
}
---

We provide some basic errors for handy use - an out-of-values error

--- possible errors+=
UnexpectedEndOfInput,
---

A mismatch error

--- possible errors+=
Mismatch,
---

And any other kind of error people might want to generate later

--- possible errors+=
Other,
---

