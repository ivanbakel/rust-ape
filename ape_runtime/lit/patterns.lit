@title Ape's pattern representation

@code_type rust .rs

--- patterns.rs
@{imports}

@{the pattern trait}
---

@s The pattern trait

The `Pattern` trait is Ape's representation of a generic way of doing runtime matching. Ape patterns are `Pattern`s, but so are many other things. A `Pattern` matches some input, which is decided by a type parameter

--- the pattern trait
pub trait Pattern<Input> {
  @{pattern features}
}

@{some handy pattern impls}
--- 

What does a `Pattern` do? That depends on its `Input` type parameter, and some `Output` type. This are decided by whatever is implementing the trait, so it's an associated type.

--- pattern features+=
type Output;
---

Then a `Pattern` will take some form of `Input`, and maybe, if it matches, produce some kind of `Output`, or have the option to fail. These details will be the same as Ape's internal parser trait: the input is a `ParseFeed`, and errors are encoded as Ape's own `Error` type.

--- imports+=
use crate::{ParseFeed, Result, Error, ErrorKind};
---

--- pattern features+=
fn pmatch<P>(self, parse_feed: &mut P) -> Result<Self::Output> where P: ParseFeed<Item=Input>;
---

This may be a little opaque, so we can describe it with an example.

@s Example impls

@ss Using Eq instances as patterns

There's a natural way to use an equatable value as a pattern - match on equality. If the next value is equal to the thing we're using as a pattern, then we match successfully - otherwise, we return an error. Note that we have to wrap in a concrete type to avoid conflicting with the previous `impl`

--- some handy pattern impls+=
pub struct Equatable<E>(E);
---

To autogenerate the mismatch error, we use the `Debug` trait, similarly to `unwrap()`, and the macro defined in the crate
--- imports+=
use std::fmt;
---

--- some handy pattern impls+=
impl<T> Pattern<T> for Equatable<T> where T: Eq, T: fmt::Debug {
  @{the Eq impl}
}
---

--- the Eq impl+=
fn pmatch<P> (self, parse_feed: &mut P) -> Result<T> where P: ParseFeed<Item=T>{
  let comparable = parse_feed.expect()?;
  let Equatable(value) = self;
  if value == comparable {
    Ok(comparable)
  } else {
    Err(mismatch!("Expected {:?}, got {:?}", value, comparable))
  }
}
---

The `Input` type is then `T`. The `Output` type is less obvious - but we'll just make it `T` - there's no reason to discard the element if there's a match.

--- the Eq impl+=
type Output = T;
---

@ss The Iterator instance

There's a natural way to use a sequence of patterns as a pattern - match all the patterns in the sequence. The `Input` for the sequence is the same as the `Input` of the individual elements - the `Output` is a `Vec` of the matched inputs. If any of the patterns fail, we return that error.

Note that, as before, this can't be done directly on the `Iterator` trait - that would conflict with the `Fn` declaration. Instead, we wrap with a concrete type for the `impl`

--- some handy pattern impls+=
pub struct Iter<I>(I);
---

and then implement the trait

--- some handy pattern impls+=
impl<Input: Clone, I> Pattern<Input> for Iter<I> where I: Iterator, I::Item: Pattern<Input> {
  type Output = Vec<<I::Item as Pattern<Input>>::Output>;

  fn pmatch<P> (self, parse_feed: &mut P) -> Result<Self::Output>
    where P: ParseFeed<Item=Input> {
    let mut matched = vec![];

    let Iter(iter) = self;

    for pattern in iter {
        let result = pattern.pmatch(parse_feed)?;

        matched.push(result);
    }

    Ok(matched)
  }
}
---

