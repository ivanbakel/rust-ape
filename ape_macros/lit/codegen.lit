@title Generating Rust from Ape

@code_type rust .rs

The codegen logic falls under one main function, which takes the AST generated by the parser

--- imports+=
use super::ast::{Pattern, PatternType};
---

and produces the code for the macro invocation

--- imports+=
use crate::proc_macro::*;
---

This logic can fail
--- imports+=
use super::parsing::{Result, Error};
---

The generated code is built inside-out - first the code for the body is generated, then it is embedded in the pattern code, 

--- code.rs
@{imports}

pub(crate) fn generate(pattern: Pattern) -> Result<TokenStream> {
  let pattern_type_signature = pattern.type_annotation.clone();
  let pattern_code = generate_pattern(pattern)?;
  @{build the pattern object}
}

fn generate_pattern(pattern: Pattern) -> Result<TokenStream> {
  let body = {
    @{generate code for body}
  };
  generate_pattern_with_body(pattern, body)
}
  
fn generate_pattern_with_body(pattern: Pattern, given_body: TokenStream) -> Result<TokenStream> {
  let body = {
    @{generate guarded body}
  };
  let matching = { 
    @{generate the matching code}
  };
  Ok(matching)
}
---

@s Generating the pattern body

The body has to actually run the code after the pattern matches, if it is defined - otherwise, the code body can be empty
--- generate code for body +=
if let Some(code) = pattern.code_block.clone() {
  quote! {
    Ok({
      $code
    })
  }
} else {
  quote! {
    Ok(()) 
  }
}
---

@s Generating the guard

Every pattern can have a guard - if the guard fails, the pattern should fail. Otherwise, the pattern succeeds - and we run the pattern body
--- generate guarded body+=
if let Some(guard) = pattern.guard {
  quote! {
    @{generate the guarded code}
  }
} else {
  given_body
}
---

The guard is just a conditional on some variables which are in scope, so we can represent it as an if. Additionally, to help the user find what condition is failing, we can use the direct printing of the `TokenStream` in the error message. Finally, we embed the body in the centre
--- generate the guarded code
if $guard {
  $given_body
} else {
  Err(ape::mismatch!("Expected the value to pass `{}`", stringify!($guard)))
}
---

@s Generating the matching code

The main part of the variant matching is a big `match` statement
--- generate the matching code
match pattern.variant {
  PatternType::Raw(rust_pattern) => {
    @{raw rust pattern}
  },
  PatternType::Sequence(mut patterns) => {
    @{sequence of patterns}
  },
  PatternType::Alternation(patterns) => {
    @{alternation of patterns}
  },
  PatternType::Negation(pattern) => {
    @{pattern negation}
  },
  PatternType::Lookahead(pattern) => {
    @{pattern lookahead}
  },
  PatternType::Optional(pattern) => {
    @{optional pattern}
  },
  PatternType::Repetition {
    pattern,
    at_least,
    at_most,
    delimiter,
  } => {
    @{repeated pattern}
  },
  PatternType::Runtime(runtime) => {
    @{runtime pattern}
  },
}
---

For a raw pattern, we can test a match and bind any variables with a simple `if let`. If there's no next token, we should error.
--- raw rust pattern
quote! {
  feed.expect().and_then(|next| {
    if let $rust_pattern = next {
      $body
    } else {
      Err(ape::mismatch!("Expected value to match `{}`", stringify!($rust_pattern)))
    }
  })
}
---

For a runtime pattern, we can test a match by simply calling the method on the `Pattern` trait implementation.
--- runtime pattern
quote! {
  let pattern = {
    $runtime
  };
  pattern.pmatch(feed).and_then(|_| {
    $body
  })
}
---

The lookahead of a pattern just involves matching it and then reverting to the previous parse-state
--- pattern lookahead
let lookahead_pattern = generate_pattern(*pattern)?;
quote! {
  let old_feed = feed.attempt();
  if let Err(error) = {
    $lookahead_pattern
  } {
    Err(error)
  } else {
    feed.commit(&old_feed);
    $body
  }
}
---

The negation of a given pattern can be tested by simply swapping the success and error states, as well as performing the lookahead logic
--- pattern negation
let inner_pattern = generate_pattern(*pattern)?;
quote! {
  let old_feed = feed.attempt();
  if let Ok(success) = {
    $inner_pattern
  } {
    Err(ape::mismatch!("Expected the pattern to fail"))
  } else {
    feed.commit(&old_feed);
    $body
  }
}
---

To make a pattern optional, we can simply discard the error state and restore the original feed - but the return type becomes an `Option` of the original return type
--- optional pattern
let inner_pattern = generate_pattern(*pattern)?;
quote! {
  let old_feed = feed.attempt();
  if let Ok(_) = {
    $inner_pattern
  } {
    {
      $body
    }.map(|success_value| Some(success_value))
  } else {
    feed.commit(&old_feed);
    Ok(None)
  }
}
---

To repeat a pattern, we can require it for `at_least` many repetitions, and make it optional until `at_most` many repetitions.
--- repeated pattern
let pattern = generate_pattern(*pattern)?;
if let Some(delimiter) = delimiter {
  let delimiter = generate_pattern(*delimiter)?;
  quote! {
    let mut matched = false;
    let mut i = 0_usize;
    loop {
      if i > $at_most {
        break Ok(());
      }
      if i >= $at_least {
        @{delimiter after the minimum matches}
        @{after the minimum matches}
      } else {
        @{delimiter before the minimum matches}
        @{before the minimum matches}
      }
      i += 1;
    }.and_then(|_| {
      $body
    })
  }
} else {
  quote! {
    let mut matched = false;
    let mut i = 0_usize;
    loop {
      if i > $at_most {
        break Ok(());
      }
      if i >= $at_least {
        @{after the minimum matches}
      } else {
        @{before the minimum matches}
      }
      i += 1;
    }.and_then(|_| {
      $body
    })
  }
}
---

The logic before we've hit the minimum number of matches is simple: if there has been at least one match, match the delimiter
--- delimiter before the minimum matches+=
if matched {
  if let Err(error) = {
    $delimiter
  } {
    break Err(error);
  }
}
---
then match the pattern.
--- before the minimum matches+=
if let Err(error) = {
  $pattern
} {
  break Err(error);
}
matched = true;
---

Once we've hit the minimum number of matches, the logic is more complicated: if there's been at least one match, we need to try to match the delimiter - but if we fail to, we simply fail out of the loop
--- delimiter after the minimum matches+=
if matched {
  let old_feed = feed.attempt();
  if let Err(_) = {
    $delimiter
  } {
    feed.commit(&old_feed);
    break Ok(());
  }
}
---
then we match the pattern - again, if we fail to match, we simply fail out of the loop
--- after the minimum matches+=
let old_feed = feed.attempt();
if let Ok(_) = {
  $pattern
} {
  matched = true;
} else {
  feed.commit(&old_feed);
  break Ok(());
}
---

To sequence patterns, we nest their success cases - if we sequence the successes, we won't have access to the variables in each successive scope. To do this, we generate the patterns from the end first, nesting in reverse
--- sequence of patterns +=
let mut nested = body;
while let Some(pattern) = patterns.pop() {
  nested = generate_pattern_with_body(pattern, nested)?;
}
nested
---

To alternate patterns, we could build each one with the given body, to allow alternate patterns to bind the same variables and have them work correctly - but this design would present some problems:
  * if the alternation appeared in the sequence, then failures after the alternation in the sequence would cause a rollback to the alternation, which is unexpected
  * the only way to not have the alternation as the top-level pattern is to bracket it, but brackets would also be expected to control scope - if a bracketed alternation produced bound variables that escaped the brackets, it would be confusing

Instead, patterns are tested by using `or_else()`, and the body is run if there was a success
--- alternation of patterns
let mut alternatives = patterns.into_iter().map(|pattern| {
  generate_pattern(pattern)
}).fold(Ok(vec![]), |acc, next| {
  let mut vec = acc?;
  let alt = next?;
  vec.push(alt);
  Ok(vec)
})?.into_iter().map(|generated|
  quote! {
    { 
      $generated
    }
  }
);
let first = alternatives.next().expect("At least one pattern in the alternative set");

let alternation = alternatives.fold(first, |alternatives, next| {
  quote! {
    $alternatives
      .or_else(|_previous_error| {
        feed.commit(&initial_feed);
        $next
      })
  }
});

quote! {
  let initial_feed = feed.attempt();
  $alternation.and_then(|_| {
    $body
  })
}
---

@ss Building the Pattern object

Finally, we have to return a value which implements the `Pattern` trait, to allow it to actually be used for matching. We can do this by wrapping the matching code we've built in a function, and returning a reference - as the `Pattern` trait is implemented for anything implementing the right `Fn` signature.

However, to fully write the function signature, we need the pattern to have filled-in type information: if it is missing, that's an error.
--- build the pattern object
if let Some(super::ast::TypeSignature { input, output }) = pattern_type_signature {
  Ok(quote! {
    {
      fn __parse<P: ape::ParseFeed<Item=$input>>(feed: &mut P) -> ape::Result<$output> {
        $pattern_code
      }
  
      &__parse
    }
  })
} else {
  Err(Error {
    location: Span::call_site(),
    message: format!("A top-level pattern must have a type annotation."),
 })
}
---

